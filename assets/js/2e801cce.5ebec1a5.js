"use strict";(self.webpackChunkdilanx_blog=self.webpackChunkdilanx_blog||[]).push([[450],{6029:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"/a-comprehensive-react-tutorial-for-beginners","metadata":{"permalink":"/a-comprehensive-react-tutorial-for-beginners","source":"@site/blog/a-comprehensive-react-tutorial-for-beginners.md","title":"A Comprehensive React Tutorial for Beginners","description":"React is a powerful JavaScript library for building interactive user interfaces (and it\'s the most popular one, too). Its component-based architecture allows for complex UIs just by combining small and isolated pieces of code. In combination with JSX, you can easily write your entire UI in JavaScript using a familiar HTML-like syntax. There\'s an official tutorial where they walk you through the basics of React by making a tic-tac-toe game, and I highly recommend checking that out for a good overview of what React is. However, since the introduction of hooks, a lot of React code you\'ll see today is written using function components as opposed to the class component alternative, so here\'s a tutorial for that. They already made tic-tac-toe, so let\'s make Wordle!","date":"2022-12-14T00:00:00.000Z","formattedDate":"December 14, 2022","tags":[{"label":"guides","permalink":"/tags/guides"},{"label":"react","permalink":"/tags/react"},{"label":"javascript","permalink":"/tags/javascript"},{"label":"typescript","permalink":"/tags/typescript"},{"label":"beginner","permalink":"/tags/beginner"}],"readingTime":24.25,"hasTruncateMarker":true,"authors":[{"name":"Dilan Nair","title":"Software Developer","url":"https://www.dilanxd.com","icon":{"letters":"DN","font":"bold 1.3rem Charter"},"key":"dilan"}],"frontMatter":{"date":"2022-12-14T00:00:00.000Z","authors":["dilan"],"tags":["guides","react","javascript","typescript","beginner"],"imageUrl":"a-comprehensive-react-tutorial-for-beginners"},"nextItem":{"title":"How Paper Manages Hundreds of Thousands of Lines of Data","permalink":"/how-paper-manages-hundreds-of-thousands-of-lines-of-data"}},"content":"[React](https://reactjs.org/) is a powerful JavaScript library for building interactive user interfaces (and it\'s the most popular one, too). Its **component**-based architecture allows for complex UIs just by combining small and isolated pieces of code. In combination with [JSX](https://reactjs.org/docs/introducing-jsx.html), you can easily write your entire UI in JavaScript using a familiar HTML-like syntax. There\'s an official [tutorial](https://reactjs.org/tutorial/tutorial.html) where they walk you through the basics of React by making a tic-tac-toe game, and I highly recommend checking that out for a good overview of what React is. However, since the introduction of [hooks](https://reactjs.org/docs/hooks-intro.html), a lot of React code you\'ll see today is written using function components as opposed to the class component alternative, so here\'s a tutorial for that. They already made tic-tac-toe, so let\'s make Wordle!\\n\\n\x3c!--truncate--\x3e\\n\\n:::caution before we start\\n\\nThis tutorial **does not** assume prior knowledge of React but **does** assume at least some prior knowledge of HTML, CSS, and JavaScript. There are tons of resources online to help you with those if you\'re new! Don\'t worry about CSS too much for this tutorial though since the starter code has it done for you.\\n\\n:::\\n\\n## About the guide\\n\\n### Why this tutorial?\\n\\nThis tutorial focuses on function components rather than class components, which is what React\'s official tutorial covers. If you\'re not sure what the difference is, this tutorial covers newer React functionality and techniques.\\n\\n### What are we making?\\n\\n[Wordle](https://www.nytimes.com/games/wordle/index.html) is a simple word puzzle game that was especially popular at the beginning of 2022. In this game, you have 6 tries to guess a five-letter word. After each try, each letter is marked as either green, yellow, or gray. Green means the letter is in the correct position, yellow means the letter is in the answer but in the wrong position, and gray means it\'s not in the answer at all. I recommend trying it out for yourself real quick!\\n\\n### JavaScript or TypeScript?\\n\\nThis tutorial covers both! All code blocks have a JavaScript tab and a TypeScript tab, so you can choose the one you prefer.\\n\\n## Setup\\n\\nYou\'re totally welcome to read this tutorial and not write any code for yourself (if that\'s what you want, skip this setup section), but you can also follow along! It\'s super easy to get things going in your own code editor.\\n\\n:::note prerequisites\\n\\nEnsure you have [Node.js](https://nodejs.org/en/) and [npm](https://www.npmjs.com/) installed. You can check if you have these installed by running `$ node -v` and `$ npm -v` in your terminal.\\n\\nThe best way to install everything is with **[nvm](https://github.com/nvm-sh/nvm#installing-and-updating)**. Follow the instructions to install nvm, then run `$ nvm install node` to install the latest version of Node.js and npm.\\n\\n:::\\n\\nFirst, get the starter code for this tutorial.\\n\\n```\\n$ npm create tutorial wordle\\n```\\n\\nYou\'ll then be prompted to select the JavaScript or TypeScript variant. Select the one you prefer. You can also get my completed source code for this project if you\'d like (only available in TypeScript).\\n\\n```\\n$ npm create tutorial wordle\\n\\nUsing tutorial project tutorial-react-wordle.\\n? Select a variant \u203a - Use arrow-keys. Return to submit.\\n\u276f   JavaScript\\n    TypeScript\\n    Completed\\n```\\n\\nMove into the project directory and install the dependencies.\\n\\n```\\n$ cd tutorial-react-wordle\\n$ npm install\\n```\\n\\nThis project uses the [Vite](https://vitejs.dev/) build tool, which includes a script to spin up the server.\\n\\n```\\n$ npm run dev\\n```\\n\\nNow, if you did everything correctly, visit the printed link in your browser and you should see a gray screen with \\"Hi\\" in small text in the middle.\\n\\nHi!! Looks like we\'re ready to get started.\\n\\n### Explore the source code\\n\\nOpen up the project in your code editor of choice (like [Visual Studio Code](https://code.visualstudio.com/)). Check out the files to get familiar with how the project is structured. We\'ll start in `App.jsx` (or `App.tsx` if you\'re using TypeScript).\\n\\n## Components\\n\\n### About React components\\n\\n**Components** are basically pieces of UI that contain a chunk of isolated code. A full UI will be made up of a bunch of these. In our case with Wordle, we\'ll have a few components. We\'ll have one for the board itself, one for a word row, and one for a letter cell. Each row will contain 5 letter cells, and the board will contain 6 rows.\\n\\nTypically, each component should be in its own file and should be the default export. **Components MUST start with an uppercase letter!** Although you can _technically_ name one completely lowercase, JSX won\'t know if you\'re referring to a custom component or an actual HTML component. For example, if you name your component `div` and try to use that in JSX, you\'ll get the default HTML div element.\\n\\n### Creating the board\\n\\nLet\'s start by creating a blank board, then replacing out our \\"Hi\\" message with the component.\\n\\nCreate a `components` directory in `src` and define a new `Board` function component:\\n\\n<langs>\\n<lang value=\\"JavaScript\\">\\n\\n```jsx title=\\"src/components/Board.jsx\\"\\nexport default function Board() {\\n  return <div className=\\"board\\"></div>;\\n}\\n```\\n\\n</lang>\\n<lang value=\\"TypeScript\\">\\n\\n```tsx title=\\"src/components/Board.tsx\\"\\nexport default function Board() {\\n  return <div className=\\"board\\"></div>;\\n}\\n```\\n\\n</lang>\\n</langs>\\n\\n:::tip\\n\\nUse the same `className` attribute values as I do if you\'re using the starter code! I\'ve already written all of the CSS we need in `src/index.css`, but you\'re welcome to add your own, of course!\\n\\n:::\\n\\nNow, let\'s add it to our default `App` component:\\n\\n<langs groupId=\\"lang\\">\\n<lang value=\\"JavaScript\\">\\n\\n```jsx title=\\"src/App.jsx\\"\\n// highlight-next-line\\nimport Board from \'./components/Board\';\\n\\nfunction App() {\\n  // highlight-start\\n  return (\\n    <div className=\\"app\\">\\n      <Board />\\n    </div>\\n  );\\n  // highlight-end\\n}\\n\\nexport default App;\\n```\\n\\n</lang>\\n<lang value=\\"TypeScript\\">\\n\\n```tsx title=\\"src/App.tsx\\"\\n// highlight-next-line\\nimport Board from \'./components/Board\';\\n\\nfunction App() {\\n  // highlight-start\\n  return (\\n    <div className=\\"app\\">\\n      <Board />\\n    </div>\\n  );\\n  // highlight-end\\n}\\n\\nexport default App;\\n```\\n\\n</lang>\\n</langs>\\n\\nNice! Let\'s create a cell component and a row component, then add a single cell to a row, then add a single row to our board.\\n\\n<langs>\\n<lang value=\\"JavaScript\\">\\n\\n```jsx title=\\"src/components/Cell.jsx\\"\\nexport default function Cell() {\\n  return <div className=\\"cell\\"></div>;\\n}\\n```\\n\\n```jsx title=\\"src/components/Row.jsx\\"\\nimport Cell from \'./Cell\';\\n\\nexport default function Row() {\\n  return (\\n    <div className=\\"row\\">\\n      <Cell />\\n    </div>\\n  );\\n}\\n```\\n\\n```jsx title=\\"src/components/Board.jsx\\"\\n// highlight-next-line\\nimport Row from \'./Row\';\\n\\nexport default function Board() {\\n  // highlight-start\\n  return (\\n    <div className=\\"board\\">\\n      <Row />\\n    </div>\\n  );\\n  // highlight-end\\n}\\n```\\n\\n</lang>\\n\\n<lang value=\\"TypeScript\\">\\n\\n```tsx title=\\"src/components/Cell.tsx\\"\\nexport default function Cell() {\\n  return <div className=\\"cell\\"></div>;\\n}\\n```\\n\\n```tsx title=\\"src/components/Row.tsx\\"\\nimport Cell from \'./Cell\';\\n\\nexport default function Row() {\\n  return (\\n    <div className=\\"row\\">\\n      <Cell />\\n    </div>\\n  );\\n}\\n```\\n\\n```tsx title=\\"src/components/Board.tsx\\"\\n// highlight-next-line\\nimport Row from \'./Row\';\\n\\nexport default function Board() {\\n  // highlight-start\\n  return (\\n    <div className=\\"board\\">\\n      <Row />\\n    </div>\\n  );\\n  // highlight-end\\n}\\n```\\n\\n</lang>\\n</langs>\\n\\nIf everything goes well, a single letter cell should appear in the middle of the screen.\\n\\n<image fm={frontMatter} src=\\"single-cell.png\\" />\\n\\nNow, add 4 more cells to the row component, and 5 more rows to the board component.\\n\\n<langs>\\n<lang value=\\"JavaScript\\">\\n\\n```jsx title=\\"src/components/Row.jsx\\"\\n// ...\\n\\nexport default function Row() {\\n  return (\\n    <div className=\\"row\\">\\n      <Cell />\\n      {/* highlight-start */}\\n      <Cell />\\n      <Cell />\\n      <Cell />\\n      <Cell />\\n      {/* highlight-end */}\\n    </div>\\n  );\\n}\\n```\\n\\n```jsx title=\\"src/components/Board.jsx\\"\\n// ...\\n\\nexport default function Board() {\\n  return (\\n    <div className=\\"board\\">\\n      <Row />\\n      {/* highlight-start */}\\n      <Row />\\n      <Row />\\n      <Row />\\n      <Row />\\n      <Row />\\n      {/* highlight-end */}\\n    </div>\\n  );\\n}\\n```\\n\\n</lang>\\n<lang value=\\"TypeScript\\">\\n\\n```tsx title=\\"src/components/Row.tsx\\"\\n// ...\\n\\nexport default function Row() {\\n  return (\\n    <div className=\\"row\\">\\n      <Cell />\\n      {/* highlight-start */}\\n      <Cell />\\n      <Cell />\\n      <Cell />\\n      <Cell />\\n      {/* highlight-end */}\\n    </div>\\n  );\\n}\\n```\\n\\n```tsx title=\\"src/components/Board.tsx\\"\\n// ...\\n\\nexport default function Board() {\\n  return (\\n    <div className=\\"board\\">\\n      <Row />\\n      {/* highlight-start */}\\n      <Row />\\n      <Row />\\n      <Row />\\n      <Row />\\n      <Row />\\n      {/* highlight-end */}\\n    </div>\\n  );\\n}\\n```\\n\\n</lang>\\n</langs>\\n\\n<image fm={frontMatter} src=\\"board.png\\" />\\n\\n## Props\\n\\n### About React props\\n\\n**Props**, short for properties, are read-only values that can be passed to components. The component will rerender when its props change. Props work similarly to HTML attributes syntactically, but their values can be any JavaScript expression.\\n\\nWith function components, props are passed to the function as a single object argument. Check out this example unrelated to our game:\\n\\n```jsx title=\\"ExampleComponent.jsx\\"\\nexport default function ExampleComponent(props) {\\n  return (\\n    <div>\\n      {props.message} {props.num}\\n    </div>\\n  );\\n}\\n```\\n\\n```jsx title=\\"ExampleApp.jsx\\"\\n// ...\\n\\nexport default function ExampleApp() {\\n  return (\\n    <div>\\n      <ExampleComponent message=\\"Hello, world!\\" num={4} />\\n    </div>\\n  );\\n}\\n```\\n\\nAny JavaScript expression is fair game, so you can even pass a function as a prop:\\n\\n```jsx title=\\"ExampleButton.jsx\\"\\nexport default function ExampleButton(props) {\\n  return <button onClick={() => props.handleClick()}>{props.text}</button>;\\n}\\n```\\n\\n```jsx title=\\"ExampleApp.jsx\\"\\n// ...\\n\\nexport default function ExampleApp() {\\n  return (\\n    <div>\\n      <ExampleButton\\n        text=\\"Click me!\\"\\n        handleClick={() => console.log(\'Hello, world!\')}\\n      />\\n    </div>\\n  );\\n}\\n```\\n\\nAnd, since props are just passed as JavaScript objects, you can [destructure](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment) them:\\n\\n```jsx title=\\"ExampleComponent.jsx\\"\\nexport default function ExampleButton({ text, handleClick }) {\\n  return <button onClick={() => handleClick()}>{text}</button>;\\n}\\n```\\n\\n### Passing data to the cells\\n\\nWe know that each cell should have a letter and a status. This status can be `\'correct\'`, `\'partial\'`, `\'incorrect\'`, or left `undefined`. The first three are the states each cell can be in when a given row is submitted, and the last one is the state each cell is in when you\'re still typing out that row. Let\'s add these as props to our cell component, and code in some logic to display the letter and the status as a background color.\\n\\n<langs>\\n<lang value=\\"JavaScript\\">\\n\\n```jsx title=\\"src/components/Cell.jsx\\"\\nexport default function Cell({ letter, status }) {\\n  let backgroundColor;\\n\\n  switch (status) {\\n    case \'correct\':\\n      backgroundColor = \'green\';\\n      break;\\n    case \'partial\':\\n      backgroundColor = \'orange\';\\n      break;\\n    case \'incorrect\':\\n      backgroundColor = \'gray\';\\n      break;\\n  }\\n\\n  return (\\n    <div className=\\"cell\\" style={{ backgroundColor }}>\\n      {letter?.toUpperCase()}\\n    </div>\\n  );\\n}\\n```\\n\\n</lang>\\n<lang value=\\"TypeScript\\">\\n\\n```tsx title=\\"src/components/Cell.tsx\\"\\nimport type { Status } from \'../types\';\\n\\ninterface CellProps {\\n  letter?: string;\\n  status?: Status;\\n}\\n\\nexport default function Cell({ letter, status }: CellData) {\\n  let backgroundColor;\\n\\n  switch (status) {\\n    case \'correct\':\\n      backgroundColor = \'green\';\\n      break;\\n    case \'partial\':\\n      backgroundColor = \'orange\';\\n      break;\\n    case \'incorrect\':\\n      backgroundColor = \'gray\';\\n      break;\\n  }\\n\\n  return (\\n    <div className=\\"cell\\" style={{ backgroundColor }}>\\n      {letter?.toUpperCase()}\\n    </div>\\n  );\\n}\\n```\\n\\n```ts title=\\"src/types.ts\\"\\nexport type Status = \'correct\' | \'partial\' | \'incorrect\';\\n```\\n\\n:::note\\n\\nThe starter code includes a line in `src/types.ts` that exports an empty object. This is just to get rid of the compiler errors because TypeScript\'s `isolatedModules` setting is enabled. You can remove it when you add these exports.\\n\\n:::\\n\\n</lang>\\n</langs>\\n\\n:::note\\n\\nNote that the `style` prop takes in an object with camelCase properties (`backgroundColor`) rather than a string like with the HTML `style` attribute! Typically, you shouldn\'t need to update style manually and can just use CSS classes, but since we\'re just dynamically changing the background color based on the status, we\'ll do so here.\\n\\nhttps://reactjs.org/docs/dom-elements.html#style\\n\\n:::\\n\\nFinally, let\'s test this by adding some dummy data to the first cell in our row component:\\n\\n<langs>\\n<lang value=\\"JavaScript\\">\\n\\n```jsx title=\\"src/components/Row.jsx\\"\\n// ...\\n\\nexport default function Row() {\\n  return (\\n    <div className=\\"row\\">\\n      {/* highlight-next-line */}\\n      <Cell letter=\\"a\\" status=\\"correct\\" />\\n      <Cell />\\n      <Cell />\\n      <Cell />\\n      <Cell />\\n    </div>\\n  );\\n}\\n```\\n\\n</lang>\\n<lang value=\\"TypeScript\\">\\n\\n```tsx title=\\"src/components/Row.tsx\\"\\n// ...\\n\\nexport default function Row() {\\n  return (\\n    <div className=\\"row\\">\\n      {/* highlight-next-line */}\\n      <Cell letter=\\"a\\" status=\\"correct\\" />\\n      <Cell />\\n      <Cell />\\n      <Cell />\\n      <Cell />\\n    </div>\\n  );\\n}\\n```\\n\\n</lang>\\n</langs>\\n\\n<image fm={frontMatter} src=\\"dummy-first-cell.png\\" />\\n\\nNow that we have that working, let\'s set up some row props so our cell data can change dynamically.\\n\\n<langs>\\n<lang value=\\"JavaScript\\">\\n\\n```jsx title=\\"src/components/Row.jsx\\"\\n// ...\\n\\nexport default function Row({ data }) {\\n  return (\\n    <div className=\\"row\\">\\n      {/* highlight-start */}\\n      <Cell {...data?.[0]} />\\n      <Cell {...data?.[1]} />\\n      <Cell {...data?.[2]} />\\n      <Cell {...data?.[3]} />\\n      <Cell {...data?.[4]} />\\n      {/* highlight-end */}\\n    </div>\\n  );\\n}\\n```\\n\\n</lang>\\n<lang value=\\"TypeScript\\">\\n\\n```tsx title=\\"src/components/Row.tsx\\"\\n// ...\\n// highlight-start\\nimport type { CellData } from \'../types\';\\n\\ninterface RowProps {\\n  data?: CellData[];\\n}\\n// highlight-end\\n\\nexport default function Row({ data }: RowProps) {\\n  return (\\n    <div className=\\"row\\">\\n      {/* highlight-start */}\\n      <Cell {...data?.[0]} />\\n      <Cell {...data?.[1]} />\\n      <Cell {...data?.[2]} />\\n      <Cell {...data?.[3]} />\\n      <Cell {...data?.[4]} />\\n      {/* highlight-end */}\\n    </div>\\n  );\\n}\\n```\\n\\n</lang>\\n</langs>\\n\\n:::note spread syntax\\n\\nHere, we used [spread syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax) `...`. This \\"spreads\\" out the properties of the object we\'re passing in, so that we can pass them in as props to the cell component. For example, if we pass in `{ letter: \'a\', status: \'correct\' }`, then the cell component will receive `letter=\\"a\\"` and `status=\\"correct\\"` as props. This is equivalent to writing it out like this:\\n\\n```jsx\\n<Cell letter={data?.[0]?.letter} status={data?.[0]?.status}>\\n```\\n\\n:::\\n\\n:::note optional chaining\\n\\nWe also used [optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining) `?.`. This allows us to immediately return `undefined` from the expression if the value on the left is `undefined`, saving us from errors about reading properties from `undefined`. This is important since we still want to render 5 cells in a row, but not all of them will have data (the blank ones won\'t).\\n\\n:::\\n\\nAt this point, our dummy data should disappear, but the board should still have all of the cells visible yet empty.\\n\\n## State and lifecycle\\n\\n### About React state\\n\\n**State** serves as a way for components to store and keep track of data that changes over time. Each component has its own state that only it (and its children that receive it as props) can access. To use state in function components, we\'ll need to use the `useState` hook.\\n\\n### About React hooks\\n\\n[**Hooks**](https://reactjs.org/docs/hooks-intro.html) let you use state and other React features in function components. They were introduced in React 16.8, so before that, function components couldn\'t use state and you\'d have to use class components instead. We\'ll be using a couple of them in this tutorial, namely `useState` and `useEffect`, but we\'ll start with `useState` for now.\\n\\n### Using `useState`\\n\\nLet\'s bring back that example app and button from earlier.\\n\\nHere\'s the button component for reference:\\n\\n```jsx title=\\"ExampleComponent.jsx\\"\\nexport default function ExampleButton({ text, handleClick }) {\\n  return <button onClick={() => handleClick()}>{text}</button>;\\n}\\n```\\n\\nNow, we\'ll make it so clicking the button increments a number stored in the app component\'s state:\\n\\n```jsx title=\\"ExampleApp.jsx\\"\\n// ...\\n// highlight-next-line\\nimport { useState } from \'react\';\\n\\nexport default function ExampleApp() {\\n  // highlight-next-line\\n  const [count, setCount] = useState(0);\\n\\n  return (\\n    <div>\\n      <ExampleButton\\n        {/* highlight-start */}\\n        text={`Clicked ${count} times`}\\n        handleClick={() => setCount(count + 1)}\\n        {/* highlight-end */}\\n      />\\n    </div>\\n  );\\n}\\n```\\n\\nThe `useState` function takes in a default value (in this case, that\'s `0`) to which the state variable `count` will be initialized. It returns a two-element array with the first element being the value of the state variable and the second being a function to update the value. Here, we destructured the array into two variables, `count` and `setCount`.\\n\\nYou probably noticed that we\'re using `setCount` to update the state rather than just updating `count` directly. This is important so that React knows when to re-render the component and to avoid unnecessarily re-rendering it if the props and state haven\'t changed.\\n\\nClicking on the button will update the state and re-render the component, causing the button text to update.\\n\\n:::tip\\n\\nYou can use as many `useState` calls as you want in a component! You should have one for each state variable that you\'re want to use.\\n\\n:::\\n\\n### Keeping track of row data\\n\\nLet\'s define some state within our board component. We\'ll use a two-dimentional array of cell data objects (letter and status) to represent each row and each cell in that row.\\n\\n<langs>\\n<lang value=\\"JavaScript\\">\\n\\n```jsx title=\\"src/components/Board.jsx\\"\\n// ...\\nimport { useState } from \'react\';\\n\\nexport default function Board() {\\n  const [rows, setRows] = useState([[]]);\\n\\n  return (\\n    <div className=\\"board\\">\\n      <Row data={rows[0]} />\\n      <Row data={rows[1]} />\\n      <Row data={rows[2]} />\\n      <Row data={rows[3]} />\\n      <Row data={rows[4]} />\\n      <Row data={rows[5]} />\\n    </div>\\n  );\\n}\\n```\\n\\n</lang>\\n<lang value=\\"TypeScript\\">\\n\\n```tsx title=\\"src/components/Board.tsx\\"\\n// ...\\nimport type { CellData } from \'../types\';\\nimport { useState } from \'react\';\\n\\nexport default function Board() {\\n  const [rows, setRows] = useState<CellData[][]>([[]]);\\n\\n  return (\\n    <div className=\\"board\\">\\n      <Row data={rows[0]} />\\n      <Row data={rows[1]} />\\n      <Row data={rows[2]} />\\n      <Row data={rows[3]} />\\n      <Row data={rows[4]} />\\n      <Row data={rows[5]} />\\n    </div>\\n  );\\n}\\n```\\n\\n</lang>\\n</langs>\\n\\nWe initialized the state variable `rows` to be an array containing one empty array to give us a starting point when entering data. This will make more sense as we implement the game logic.\\n\\n### The game logic\\n\\nBefore we directly modify our state and implement keyboard functionality, let\'s create a function to handle the game logic.\\n\\nLet\'s define a new exported function in our `src/common.js` (or `src/common.ts`) file that takes in a key, the Wordle word, and our current data 2D array, which will return a new 2D array with the updated data:\\n\\n<langs>\\n<lang value=\\"JavaScript\\">\\n\\n```js title=\\"src/common.js\\"\\n// Import the words list. The JSON file should already be in the `src` directory.\\nimport words from \'./words.json\';\\n\\nexport function update(key, word, rows) {\\n  // In Wordle, we\'re only ever updating the last row.\\n  const current = rows.length - 1;\\n\\n  // Let\'s separate out the old rows since we\'re not changing them,\\n  // then spread the current row into a new array.\\n  // This is important for STATE IMMUTABILITY, which we\'ll talk about later.\\n  let old = rows.slice(0, current);\\n  let row = [...rows[current]];\\n\\n  // Use regex to check if the key is a letter.\\n  if (/^[a-z]$/.test(key)) {\\n    // If the row already has 5 letters, don\'t update anything.\\n    if (row.length === 5) return rows;\\n\\n    // Otherwise, add the new letter to the row.\\n    // We\'ll leave the status undefined for now since the player\\n    // is still typing the word and can backspace the letter.\\n    row.push({ letter: key });\\n  }\\n\\n  // If the key is backspace, remove the last letter from the row.\\n  if (key === \'Backspace\') {\\n    row.pop();\\n  }\\n\\n  // Check if the key is enter\\n  if (key === \'Enter\') {\\n    // Make sure the row has 5 letters and that it makes up a valid word.\\n    // If not, return the old rows so nothing is updated.\\n    // See isWord below this function.\\n    if (row.length !== 5 || !isWord(row)) return rows;\\n\\n    // Update the row with each letter\'s status changed.\\n    // See checkWord below this function.\\n    row = checkWord(word, rows[current]);\\n\\n    // If we\'re not yet at the end of the game, return the updated rows plus\\n    // an empty row for the next attempt.\\n    if (rows.length < 6) {\\n      return [...old, row, []];\\n    }\\n  }\\n\\n  // Return the updated rows.\\n  return [...old, row];\\n}\\n\\n// Check if the row makes up a valid word.\\nexport function isWord(row) {\\n  const word = row.map(({ letter }) => letter).join(\'\');\\n  return words.includes(word);\\n}\\n\\n// Determine the correctness of each letter in the attempt.\\nexport function checkWord(word, row) {\\n  const letters = word.split(\'\');\\n  return row.map(({ letter }, i) => {\\n    let status: Status;\\n    if (letter === letters[i]) {\\n      status = \'correct\';\\n    } else if (letters.includes(letter)) {\\n      status = \'partial\';\\n    } else {\\n      status = \'incorrect\';\\n    }\\n\\n    return {\\n      letter,\\n      status,\\n    };\\n  });\\n}\\n```\\n\\n</lang>\\n<lang value=\\"TypeScript\\">\\n\\n```ts title=\\"src/common.ts\\"\\nimport type { CellData, Status } from \'./types\';\\n// Import the words list. The JSON file should already be in the `src` directory.\\nimport words from \'./words.json\';\\n\\nexport function update(key: string, word: string, rows: CellData[][]) {\\n  // In Wordle, we\'re only ever updating the last row.\\n  const current = rows.length - 1;\\n\\n  // Let\'s separate out the old rows since we\'re not changing them,\\n  // then spread the current row into a new array.\\n  // This is important for STATE IMMUTABILITY, which we\'ll talk about later.\\n  let old = rows.slice(0, current);\\n  let row = [...rows[current]];\\n\\n  // Use regex to check if the key is a letter.\\n  if (/^[a-z]$/.test(key)) {\\n    // If the row already has 5 letters, don\'t update anything.\\n    if (row.length === 5) return rows;\\n\\n    // Otherwise, add the new letter to the row.\\n    // We\'ll leave the status undefined for now since the player\\n    // is still typing the word and can backspace the letter.\\n    row.push({ letter: key });\\n  }\\n\\n  // If the key is backspace, remove the last letter from the row.\\n  if (key === \'Backspace\') {\\n    row.pop();\\n  }\\n\\n  // Check if the key is enter\\n  if (key === \'Enter\') {\\n    // Make sure the row has 5 letters and that it makes up a valid word.\\n    // If not, return the old rows so nothing is updated.\\n    // See isWord below this function.\\n    if (row.length !== 5 || !isWord(row)) return rows;\\n\\n    // Update the row with each letter\'s status changed.\\n    // See checkWord below this function.\\n    row = checkWord(word, rows[current]);\\n\\n    // If we\'re not yet at the end of the game, return the updated rows plus\\n    // an empty row for the next attempt.\\n    if (rows.length < 6) {\\n      return [...old, row, []];\\n    }\\n  }\\n\\n  // Return the updated rows.\\n  return [...old, row];\\n}\\n\\n// Check if the row makes up a valid word.\\nexport function isWord(row: CellData[]) {\\n  const word = row.map(({ letter }) => letter).join(\'\');\\n  return words.includes(word);\\n}\\n\\n// Determine the correctness of each letter in the attempt.\\nexport function checkWord(word: string, row: CellData[]) {\\n  const letters = word.split(\'\');\\n  return row.map(({ letter }, i) => {\\n    let status: Status;\\n    if (letter === letters[i]) {\\n      status = \'correct\';\\n    } else if (letters.includes(letter)) {\\n      status = \'partial\';\\n    } else {\\n      status = \'incorrect\';\\n    }\\n\\n    return {\\n      letter,\\n      status,\\n    };\\n  });\\n}\\n```\\n\\n</lang>\\n</langs>\\n\\n### State immutability\\n\\nIn our logic code, we created a copy of the row we were modifying (that\'s why we did `let row = [...rows[current]]` instead of `let row = rows[current]`), and then we returned a new array with the updated row. This is done for the same reason we talked about in the [using `useState`](#using-usestate) section, but is a bit more complicated here.\\n\\nLet\'s say you have an array `x` of numbers and you add the number `5` to it:\\n\\n```js\\nx.push(5);\\n```\\n\\nThis doesn\'t return a new array but rather updates the array in place (reference rather than copy).\\n\\nWe _could_ do something like this:\\n\\n```js\\n// assume state variable x with the setX exists where x is an array\\nx.push(5);\\nsetX(x);\\n```\\n\\nThe problem with this is that we\'re updating `x` through a reference, which means `x` itself is left unchanged while the actual array value `x` points to gets a new element. When we run `setX`, React doesn\'t know that the variable changed. While this could work on some occasions, the user may not always see the updated result since the component wouldn\'t know to re-render.\\n\\nThe solution would be something like this:\\n\\n```js\\nconst y = [...x];\\ny.push(5);\\nsetX(y);\\n\\n// this works, too\\nsetX([...x, y]);\\n```\\n\\n### Adding keyboard functionality\\n\\nLet\'s make it so our board\'s state updates based on our keyboard input.\\n\\nDefine a handler function within the board component:\\n\\n<langs>\\n<lang value=\\"JavaScript\\">\\n\\n```jsx title=\\"src/components/Board.jsx\\"\\n// ...\\nimport { update } from \'../common\';\\n\\n// Let\'s hardcode a word for now.\\nconst word = \'react\';\\n\\nexport default function Board() {\\n  // ...\\n\\n  const handleKeyUp = (e) => {\\n    setRows(update(e.key, word, rows));\\n  };\\n\\n  // ...\\n}\\n```\\n\\n</lang>\\n<lang value=\\"TypeScript\\">\\n\\n```tsx title=\\"src/components/Board.tsx\\"\\n// ...\\nimport { update } from \'../common\';\\n\\n// Let\'s hardcode a word for now.\\nconst word = \'react\';\\n\\nexport default function Board() {\\n  // ...\\n\\n  const handleKeyUp = (e: KeyboardEvent) => {\\n    setRows(update(e.key, word, rows));\\n  };\\n\\n  // ...\\n}\\n```\\n\\n</lang>\\n</langs>\\n\\nHere\'s where it gets interesting. We need to add this handler to our HTML document to allow us to listen for keyboard events on the page. Normally, that\'s done with the following JavaScript:\\n\\n```js\\ndocument.addEventListener(\'keyup\', handleKeyUp);\\n```\\n\\nHowever, since we\'re updating state within the component, the functions must all be defined within the component somehow. But the function runs every time the component is re-rendered. We wouldn\'t want a new event listener to be added every time, so we need to get this code to run only once.\\n\\n### Using `useEffect`\\n\\nThe `useEffect` hook allows us to manage allows us to execute code based on the [lifecycle](https://reactjs.org/docs/state-and-lifecycle.html#adding-lifecycle-methods-to-a-class) of the component. We can use it to run code when only certain values change, or just when the component is first rendered (this is when the component is **mounted**).\\n\\n:::note\\n\\nOperations that should only be done once and that could affect other components like data fetching and manually changing the DOM (like we\'re doing with the event listener) are called \\"side effects\\" (or \\"effects\\" for short). This is why it\'s called the `useEffect` hook!\\n\\nhttps://reactjs.org/docs/hooks-overview.html#effect-hook\\n\\n:::\\n\\nLet\'s move the event listener code into the callback argument for `useEffect`.\\n\\n<langs>\\n<lang value=\\"JavaScript\\">\\n\\n```jsx title=\\"src/components/Board.jsx\\"\\n// ...\\nimport { useEffect, useState } from \'react\';\\n\\nexport default function Board() {\\n  // ...\\n\\n  useEffect(() => {\\n    const handleKeyUp = (e) => {\\n      setRows((prev) => update(e.key, word, prev));\\n    };\\n\\n    document.addEventListener(\'keyup\', handleKeyUp);\\n  }, []);\\n\\n  // ...\\n}\\n```\\n\\n</lang>\\n<lang value=\\"TypeScript\\">\\n\\n```tsx title=\\"src/components/Board.tsx\\"\\n// ...\\nimport { useEffect, useState } from \'react\';\\n\\nexport default function Board() {\\n  // ...\\n\\n  useEffect(() => {\\n    const handleKeyUp = (e: KeyboardEvent) => {\\n      setRows((prev) => update(e.key, word, prev));\\n    };\\n\\n    document.addEventListener(\'keyup\', handleKeyUp);\\n  }, []);\\n\\n  // ...\\n}\\n```\\n\\n</lang>\\n</langs>\\n\\nFirstly, notice how we passed `setRows` a function rather than a value and switched the third argument of `update` from `rows` to `prev`. Since we only add the event listener once, the value of the `rows` variable that we pass in will always be what it was when the component initially mounted. Changing the argument to a function allows `setRows` to call it with the current value of the state, which we can then pass to `update`.\\n\\n:::tip try it out!\\n\\nIf you keep it as it was before (`setRows(update(e.key, word, rows))`), notice what happens. The letter in the first cell will be replaced with each letter you type! `setRows` ran successfully so the first letter appears, but `rows` is still empty as an argument to that function.\\n\\n:::\\n\\nSecondly, the second argument of `useEffect` is an array of values that the component should watch for changes (its dependencies). If any of the values change, the callback function will be run again. Passing an empty array means that it\'ll only run once when the component mounts, and passing no array means that it\'ll run every time the component re-renders.\\n\\n:::danger watch out!\\n\\nDo **not** update state for any of the dependencies within your `useEffect`. For example, if state variable `x` is a dependency (`useEffect(() => {}, [x])`), there should not be a call to `setX` within the callback function. Remember that the `useEffect` callback runs every time one of its dependencies changes, so if you update the dependency\'s value within the callback, it\'ll loop infinitely. It\'s safe to update state for state variables that aren\'t dependencies (and for all variables if an empty array is passed in).\\n\\n:::\\n\\nFinally, when the component **unmounts**, we should remove the event listener. The `useEffect` callback argument can return a function that will be called when the component unmounts. This is what that would look like:\\n\\n<langs>\\n<lang value=\\"JavaScript\\">\\n\\n```jsx title=\\"src/components/Board.jsx\\"\\n// ...\\n\\nexport default function Board() {\\n  // ...\\n\\n  useEffect(() => {\\n    const handleKeyUp = (e) => {\\n      setRows((prev) => update(e.key, word, prev));\\n    };\\n\\n    document.addEventListener(\'keyup\', handleKeyUp);\\n\\n    // highlight-start\\n    return () => {\\n      document.removeEventListener(\'keyup\', handleKeyUp);\\n    };\\n    // highlight-end\\n  }, []);\\n\\n  // ...\\n}\\n```\\n\\n</lang>\\n<lang value=\\"TypeScript\\">\\n\\n```tsx title=\\"src/components/Board.tsx\\"\\n// ...\\n\\nexport default function Board() {\\n  // ...\\n\\n  useEffect(() => {\\n    const handleKeyUp = (e: KeyboardEvent) => {\\n      setRows((prev) => update(e.key, word, prev));\\n    };\\n\\n    document.addEventListener(\'keyup\', handleKeyUp);\\n\\n    // highlight-start\\n    return () => {\\n      document.removeEventListener(\'keyup\', handleKeyUp);\\n    };\\n    // highlight-end\\n  }, []);\\n\\n  // ...\\n}\\n```\\n\\n</lang>\\n</langs>\\n\\nNow, the game should be fully functional! We hardcoded the word \'react\' so try playing Wordle to \\"guess\\" that word.\\n\\n<image fm={frontMatter} src=\\"complete-react.png\\" />\\n\\n### Finishing up\\n\\nLet\'s add a function to our `src/common.js` (or `src/common.ts`) file to pick a random word from our list, then add one more state variable to store the random word for the board. It won\'t change from its initial value, so we only need to destructure the first element. Don\'t forget to remove the hardcoded word variable, by the way!\\n\\n<langs>\\n<lang value=\\"JavaScript\\">\\n\\n```js title=\\"src/common.js\\"\\n// ...\\n\\nexport function getRandomWord() {\\n  return words[Math.floor(Math.random() * words.length)];\\n}\\n\\n// ...\\n```\\n\\n```jsx title=\\"src/components/Board.jsx\\"\\n// ...\\nimport { getRandomWord, update } from \'../common\';\\n\\nexport default function Board() {\\n  const [word] = useState(getRandomWord());\\n\\n  // ...\\n}\\n```\\n\\n</lang>\\n<lang value=\\"TypeScript\\">\\n\\n```ts title=\\"src/common.ts\\"\\n// ...\\n\\nexport function getRandomWord() {\\n  return words[Math.floor(Math.random() * words.length)];\\n}\\n\\n// ...\\n```\\n\\n```tsx title=\\"src/components/Board.tsx\\"\\n// ...\\n\\nexport default function Board() {\\n  // <string> isn\'t necessary here since the type is inferred\\n  // but you can have it if you want\\n  const [word] = useState<string>(getRandomWord());\\n\\n  // ...\\n}\\n```\\n\\n</lang>\\n</langs>\\n\\n## Conclusion\\n\\nThat\'s it. We\'ve built a fully functional Wordle game using React and its features like components, props, state, lifecycle, and hooks. Chances are you probably aren\'t gonna be building a lot of games using React since the main intent is to build dynamic user interfaces, but it was still a fun project to get familiar with the features. Hopefully you\'ll be able to apply this in your own React projects!\\n\\n### Community\\n\\nRun into any issues or have any questions? Get a conversation going on the [discussion board](https://github.com/dilanx/dilan.blog/discussions).\\n\\nIf you notice a problem with anything in this post, please open an [issue](https://github.com/dilanx/dilan.blog/issues)."},{"id":"/how-paper-manages-hundreds-of-thousands-of-lines-of-data","metadata":{"permalink":"/how-paper-manages-hundreds-of-thousands-of-lines-of-data","source":"@site/blog/how-paper-manages-hundreds-of-thousands-of-lines-of-data.md","title":"How Paper Manages Hundreds of Thousands of Lines of Data","description":"What makes Paper, Northwestern\'s course planning tool, useful to thousands of students is its course data. Obviously. A website for planning courses should have courses to plan. For you, the user, simply visiting the site puts all of the latest data right in front of you, and all of it is referenced by the save data system to automatically prepare your plan or schedule quickly, whether it\'s matching it to one of your account entries or decoding it from the URL or any of the other ways the system tries to make it as easy as possible for you. While you wait usually less than a second for everything to be ready, there\'s a lot going on in the background to make it possible!","date":"2022-12-11T00:00:00.000Z","formattedDate":"December 11, 2022","tags":[{"label":"projects","permalink":"/tags/projects"},{"label":"paper","permalink":"/tags/paper"},{"label":"northwestern","permalink":"/tags/northwestern"}],"readingTime":6.89,"hasTruncateMarker":true,"authors":[{"name":"Dilan Nair","title":"Software Developer","url":"https://www.dilanxd.com","icon":{"letters":"DN","font":"bold 1.3rem Charter"},"key":"dilan"}],"frontMatter":{"date":"2022-12-11T00:00:00.000Z","authors":["dilan"],"tags":["projects","paper","northwestern"]},"prevItem":{"title":"A Comprehensive React Tutorial for Beginners","permalink":"/a-comprehensive-react-tutorial-for-beginners"}},"content":"What makes [Paper](https://www.dilanxd.com/paper), Northwestern\'s course planning tool, useful to thousands of students is its course data. Obviously. A website for planning courses should have courses to plan. For you, the user, simply visiting the site puts all of the latest data right in front of you, and all of it is referenced by the **save data system** to automatically prepare your plan or schedule quickly, whether it\'s matching it to one of your account entries or decoding it from the URL or any of the other ways the system tries to make it as easy as possible for you. While you wait usually less than a second for everything to be ready, there\'s a lot going on in the background to make it possible!\\n\\n\x3c!--truncate--\x3e\\n\\n## Gathering the course data\\n\\n### The data the school provides\\n\\nPaper is developed in partnership with [Northwestern University Information Technology](https://www.it.northwestern.edu) and the [Northwestern University Office of the Registrar](https://www.registrar.northwestern.edu), both of which provide specific portions of official data.\\n\\nThe registrar\'s office provides general data (descriptions, distros, prereqs, units, etc.) for all courses offered at Northwestern, while NUIT exposes an API to access quarter-specific data (course sections and their time slots, instructors, locations, etc.). While the planning functionality of Paper primarily uses the general data and the scheduling functionality uses the quarter-specific data, both datasets are smartly integrated to display all of the relevant info very easily in both views.\\n\\n### Keeping things fast\\n\\nDealing with such a large amount of data can be very inefficient if done poorly, and that\'s no fun. Imagine having to wait for several seconds (or even minutes??) just to find courses for a given subject (that sounds like CAESAR, to be honest). It\'s certainly not too difficult to get all of the data once and just save it for later, but a challenge arises when trying to keep that same data up to date.\\n\\nThis was a huge focus of mine when developing Paper. Thanks to a lot of systems working together behind-the-scenes, an efficient solution was possible. Let\'s talk about the quarter-specific schedule data, since that changes much more often than the general plan data.\\n\\n### Retrieving the data\\n\\nA simple way to ensure that the user has the latest data is just to make API calls to CAESAR every time they load Paper. Well, it sometimes takes around 1-2 seconds just to retrieve data for 30 computer science courses, so you could probably imagine how long retrieving data for over 2000 courses for an upcoming quarter would take. Retrieving all of the courses data takes around 1-2 minutes. While that doesn\'t seem like a lot, imagine if you had to wait 1-2 minutes every single time you wanted to use Paper. Yeah, no.\\n\\nTo solve this issue, I developed a standalone **data retrieval and management system** (it\'s also open source so you can find the source code [here](https://github.com/dilanx/paper.nu-data)). It\'s essentially a command-line interface that runs on a cron job scheduled three times a week on the server to retrieve the latest course data and parse it into a form that is compact and usable by Paper.\\n\\nThe data is then sent to my content delivery network (CDN), which specializes in caching the data and efficiently delivering it to the client. At the same time, the Paper API (the service that also manages user data) keeps track of when the cache was updated.\\n\\nThe client has its own in-browser cache. Each time you access Paper, the site sends a request to the Paper API to compare the timestamp of the data on the CDN to the timestamp of the data in the local cache. If there\'s a mismatch, the client will replace the local data with the data on the CDN. Because the CDN stores data in the format Paper likes, this data load operation doesn\'t even take a second (unless your Wi-Fi sucks\u2014there\'s nothing I can do about that).\\n\\nA maximum of three sets of schedule data are cached in the browser. This allows you to switch between quarters in Paper (like if you\'re loading a previous quarter\'s schedule from your account) without having to fetch the data over and over again. If all three caches are in use and you try getting data for a fourth quarter, the oldest cache will be replaced. If there\'s newer data for a quarter that a cache already has data for, then that cache will be updated with the new data. There\'s a lot of stuff going on here, but it\'s all done very quickly. Computers are fast.\\n\\n## Interpreting user data\\n\\nManaging and saving user data is super important so you don\'t lose all of your plan or schedule data when you leave the site. Rather than just saving a complete copy of each course on your plan or section on your schedule, the data is serialized further to lessen the amount of unnecessary information used just for saving, especially when all of the course data is already available separately. This is especially important for the **URL save data system** so that you don\'t have to save or share an insanely long URL.\\n\\nThe data is serialized into a **data string** that looks something like this:\\n\\n```\\ny0q0=027_111-0%2C027_211-0&y0q1=027_214-0\\n```\\n\\nPaper **data strings** were implemented in the first version of Plan Northwestern (Paper\'s predecessor before it merged with salad.nu) when the account system didn\'t exist. All data would be saved in the URL and browser storage only, so you would have to swap URLs to switch between plans (browser storage only saved the most recently edited plan). If you\'re familiar with the structure of a URL [query string](https://en.wikipedia.org/wiki/Query_string), then you may have noticed that this is one of them.\\n\\nFor plans, each parameter\'s key is in the form `yYqQ` where `Y` is the year number (0-9 for a max of 10 years) and `Q` is the quarter number (0-3 for a max of 4 quarters). The value is a comma-separated list (URL encoded as `%2C`) of courses for that year and quarter. The 3 numbers before the underscore correspond to a Paper-specific subject ID. The example above shows `027` for all of the courses which in this case corresponds to the subject `COMP_SCI`. After the subject ID is the course catalog number. Thus, the data string above represents a plan that has `COMP_SCI 111-0` and `COMP_SCI 211-0` in the fall of the first year, and `COMP_SCI 214-0` in the winter of the first year.\\n\\nBookmarked courses (both for credit and not for credit) are also included within their own parameter key of `f`.\\n\\nNow, here\'s an example data string for a schedule:\\n\\n```\\nt=4890&s=015362-1&sf=004134\\n```\\n\\nThe `t` parameter contains the Northwestern-provided term ID to which the schedule belongs, and the `s` parameter contains a comma-separated list of Northwestern course IDs (before the hyphen) and which section is on the schedule (after the hyphen). There\'s also the `sf` parameter that includes the bookmarked courses.\\n\\nCourse IDs are used in schedule data strings but not in plan data strings because the first version of Plan Northwestern did not use data that included those IDs (instead, course data from the online course catalog was scraped).\\n\\nEven though these data strings are query strings intended for URLs, they\'re also used in browser storage and in account data to save plans and schedules.\\n\\nWhen a plan or schedule is loaded, Paper will parse the data string and match each element to the corresponding courses and sections. If an invalid course appears in a plan data string, the plan load will fail with an error popup. If an invalid course section appears in a schedule data string, that specific section will be skipped, but the rest of the schedule will still be loaded (this is necessary since classes that may have originally been offered for an upcoming quarter may no longer be offered and are no longer on CAESAR). If both plan parameters and schedule parameters appear in the same data string, the schedule will be prioritized and the plan\'s parameters will be removed. Loading URLs or the browser storage will also have Paper scan the account plans and schedules and automatically activate the one with the same data so you don\'t have to manually activate your plan or schedule if you reload the page."}]}')}}]);